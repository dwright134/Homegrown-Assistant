
substitutions:
  switch_light: "switch.mini_plug_3"
  switch_irrigation_pump: "switch.pump_valve"
  datetime_lights_on: "input_datetime.4x4_lights_on"
  datetime_lights_off: "input_datetime.4x4_lights_off"
  datetime_p2window_close: "input_datetime.4x4_p2_window_close"
  boolean_maintainance_mode: "input_boolean.4x4_maintainence_mode"
  uart_tx_pin: "12" # This is the TX pin the RS485 adapter is connected to
  uart_rx_pin: "13" # This is the RX pin the RS485 adapter is conencted to

<<: !include addons/thcs-config.yaml  # This file has the UART settings, and number variables in it
 
sensor:
# Raw moisture from 0-100 from the sensor
  - platform: modbus_controller
    name: "Moisture"  
    id: WC
    address: 0x0000
    unit_of_measurement: "%"
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      lambda: return (x / 10);
    state_class: measurement
# Temp in C from the THCS  
  - platform: modbus_controller
    name: "Temp" 
    id: C
    address: 0x0001
    unit_of_measurement: "Â°C"
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 1
    state_class: measurement
# Raw conductivity from the THCS, used for pwEC calculatiions
  - platform: modbus_controller
    name: "Conductivity"  
    id: EC
    address: 0x0002
    unit_of_measurement: "ms/cm"
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      lambda: return x;
    state_class: measurement
# This is a "TDS" output from the sensor in PPM, not sure what conversion or accuracy.    
  - platform: modbus_controller
    name: "TDS"  
    disabled_by_default: True  # user has to enable it first
    id: TDS
    address: 0x0004
    unit_of_measurement: "ppm"
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      lambda: return x;
    state_class: measurement

# This template is estimating the VWC based on raw moisture and a 66.7% VWC Coco coir
  - platform: template
    name: "VWC"  
    internal: False
    id: VWC
    accuracy_decimals: 1
    update_interval: 30s
    lambda: |-
      float soil_hum = id(WC).state;
      float adjusted_vwc = -0.0020844495456097786 * soil_hum * soil_hum + 0.8758395803818368 * soil_hum - 0.007765958483453483;
      return adjusted_vwc;
    state_class: measurement
    unit_of_measurement: "%"

#  This calculation is gettin the pore water EC based on the hilhorst method, calibrated for coco
  - platform: template
    name: "pwEC"
    id: pw_ec
    state_class: measurement
    unit_of_measurement: "ms/cm"
    accuracy_decimals: 1
    update_interval: 30s
    lambda: |-
      float soil_ec = id(EC).state;
      float soil_temp = id(C).state;
      float soil_hum = id(WC).state;
      //soil_ec = 1.93 * soil_ec - 270.8;
      soil_ec = 0.0000014403 * soil_ec * soil_ec * soil_ec - 0.0036 * soil_ec * soil_ec + 3.7525 * soil_ec - 814.1833;
      /**
      * Bulk EC temperature correction. Test and use if necessary.
      */
      // Soil EC temp correction based on the Teros 12 manual. https://github.com/kromadg/soil-sensor/issues/1
      soil_ec = soil_ec / (1.0 + 0.019 * (soil_temp - 25));
      // the teros bulk_permittivity was calculated from the teros temperature, teros bulk ec and teros pwec by Hilhorst 2000 model
      float soil_apparent_dieletric_constant = 1.3088 + 0.1439 * soil_hum + 0.0076 * soil_hum * soil_hum;

      float soil_bulk_permittivity = soil_apparent_dieletric_constant;  /// Hamed 2015 (apparent_dieletric_constant is the real part of permittivity)
      float soil_pore_permittivity = 80.3 - 0.37 * (soil_temp - 20); /// same as water 80.3 and corrected for temperature

      // converting bulk EC to pore water EC
      float soil_pw_ec;
      if (soil_bulk_permittivity > 4.1)
          soil_pw_ec = ((soil_pore_permittivity * soil_ec) / (soil_bulk_permittivity - 4.1) / 1000); /// from Hilhorst 2000.
      else
          soil_pw_ec = 0;
      return soil_pw_ec;

# Some wifi sensors
  - platform: wifi_signal # Reports the WiFi signal strength/RSSI in dB
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"
  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_signal_db
    name: "WiFi Signal Percent"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"
    device_class: ""
# reports uptime
  - platform: uptime  
    name: Uptime
    update_interval: 60s
    entity_category: diagnostic


# For P1 and P2 Irrigation times, we take:
#  - the media volume
#  - the flow rate of our drippers. how much water each plant gets per minute, scale this with how many drippers per plant.
#  - the max VWC, in this case 66.7%
#  - the target shot % size
# And we calculate how many ml of water that target shot % should be,
# and how many seconds we should run the pump to reach that target ml of water
  - platform: template
    id: p1_irrigation_time
    name: "P1 Irrigation Time"
    icon: "mdi:clock-outline"
    lambda: |-
      float dryback_target = (id(p1_shot_size).state) / 100;
      float media_volume_liters = id(media_volume).state * 3.78541;
      float water_holding_capacity = 0.667;
      float water_capacity_liters = media_volume_liters * water_holding_capacity;
      float dryback_percent_water_liters = water_capacity_liters * dryback_target;
      float dryback_percent_water_ml = dryback_percent_water_liters * 1000;
      float pump_run_time_seconds = dryback_percent_water_ml / (id(drip_rate).state / 60);
      return pump_run_time_seconds;

# The P1/P2 Shot volume targets are calculated the same way as the irrigation time, just returns the volume of water in ml
  - platform: template
    id: p1_shot_volume
    name: "P1 Shot Volume Target"
    icon: "mdi:clock-outline"
    lambda: |-
      float shot_target = (id(p1_shot_size).state) / 100;
      float media_volume_gallons = id(media_volume).state;
      float media_volume_liters = media_volume_gallons * 3.78541;
      float water_holding_capacity = 0.667;
      float water_capacity_liters = media_volume_liters * water_holding_capacity;
      float shot_percent_water_liters = water_capacity_liters * shot_target;
      float shot_percent_water_ml = shot_percent_water_liters * 1000;
      return shot_percent_water_ml;

# This sensor will end up being the highest VWC we get to in P1 between irrigation spikes.
# It will be the value our p2 dryback target vwc% will be based on, p1 runoff wc - p2 dryback target. For vegetative phases.
  - platform: template
    id: p1_runoff_wc
    name: "p1 Runoff WC"
    icon: "mdi:water-percent"

# This sensor is the same as the previous one but for our P2 shots
  - platform: template
    id: p2_irrigation_time
    name: "P2 Irrigation Time"
    icon: "mdi:clock-outline"
    lambda: |-
      float dryback_target = (id(p2_shot_size).state) / 100;
      float media_volume_liters = id(media_volume).state * 3.78541;
      float water_holding_capacity = 0.667;
      float water_capacity_liters = media_volume_liters * water_holding_capacity;
      float dryback_percent_water_liters = water_capacity_liters * dryback_target;
      float dryback_percent_water_ml = dryback_percent_water_liters * 1000;
      float pump_run_time_seconds = dryback_percent_water_ml / (id(drip_rate).state / 60);
      return pump_run_time_seconds;
  - platform: template
    id: p2_shot_volume
    name: "P2 Shot Volume Target" # Same as P1
    icon: "mdi:clock-outline"
    lambda: |-
      float shot_target = (id(p2_shot_size).state) / 100;
      float media_volume_gallons = id(media_volume).state;
      float media_volume_liters = media_volume_gallons * 3.78541;
      float water_holding_capacity = 0.66;
      float water_capacity_liters = media_volume_liters * water_holding_capacity;
      float shot_percent_water_liters = water_capacity_liters * shot_target;
      float shot_percent_water_ml = shot_percent_water_liters * 1000;
      return shot_percent_water_ml;

# For the P2 minimum VWC target sensor, depending on whether we are vegetative or generative,
# we aim for a dryback either from the maximum VWC during P1, so we can stay within runoff territory and keep EC lowering shot to shot
# Or from the base VWC we detected as field capacity by the end of P1. instead of from runoff VWC,
# This enables us to just stay at or under field capacity and let the pwEC rise as VWC gets lower.
  - platform: template
    id: p2_min_wc_target
    name: "P2 Min VWC Target"
    icon: "mdi:water-percent"
    lambda: |-
      if (id(steering_phase).state == "Vegetative - Veg" || id(steering_phase).state == "Vegetative - bulk") {
        return (id(p1_runoff_wc).state - id(p2_dryback_target).state);
      } else {
        return (id(field_capacity).state - id(p2_dryback_target).state);
      }

# This will just be the VWC P3 ends at, either because we reached P0 dryback goal or P3 dryback goal
  - platform: template
    id: p3_end_wc
    name: "P3 End VWC"
    icon: "mdi:water-percent"

# P3 Last dryback will be calculated each morning as soon as P1 starts, based on start and end p3 vwc
  - platform: template
    id: p3_last_dryback
    name: "P3 Last Dryback"
    icon: "mdi:water-percent"
    lambda: return id(p3_start_wc).state - id(p3_end_wc).state;

# Will be set at lights off to the last high VWC value after the most recent irrigation
  - platform: template
    id: p3_start_wc
    name: "P3 Start WC"
    icon: "mdi:water-percent"

# VWC at lights on, so we know when we hit the P0 dryback goal
  - platform: template
    id: p3_wc_at_lights_on
    name: "P3 WC at Lights On"
    icon: "mdi:lightbulb-on-outline"
    internal: True

# The current value of dryback from last known high value til now.
  - platform: template
    id: currentdryback
    name: "Current Dryback"
    icon: "mdi:water-percent"
    lambda: return id(last_high).state - id(VWC).state;

# This is going to be set in the P1 script once it detects field capacity,
# It presumes field capacity once the VWC at time of P1 irrigation is less than 2% from VWC at previous irrigation 
  - platform: template
    id: field_capacity
    name: "Field Capacity"
    icon: "mdi:water-percent"

# This will get updated everytime VWC updates, if current VCW is > this value.
# It will also get reset between irrigations, so we can track each dryback and irrigation event
  - platform: template
    id: last_high
    name: "Last High"
    icon: "mdi:arrow-up-bold-circle-outline"
    internal: true
# Similar to last high except gets set at each irrigation event.
  - platform: template
    id: last_low
    name: "Last Low"
    icon: "mdi:arrow-down-bold-circle-outline"
    internal: True

# We calculate our target P3 VWC based on subtracting our P3 dryback target % from our last high VWC value
  - platform: template
    id: p3_target_wc
    name: "P3 Target WC"
    icon: "mdi:water-percent"
    lambda: |-
      return id(last_high).state - id(p3_dryback_target).state;
    
text_sensor:
  - platform: wifi_info
    ip_address:
      name: IP Address
      entity_category: diagnostic

# This is just a text sensor that will update each time we irrigate
  - platform: template
    name: "P1 Shots"
    id: p1_shot_count_display
    icon: mdi:tally-mark-5
    entity_category: config

# Here we define our maintainence mode variable. This can be made into an internal boolean instead if dont already have this in HA. but i like it betteri n HA.
  - platform: homeassistant
    name: 4x4 Maintainence status
    internal: False
    entity_id: ${boolean_maintainance_mode}

# we need to know what time lights on and lights of is to start P0 and get the day started.
  - platform: homeassistant
    name: Lights On
    id: lights_on_time
    internal: false
    entity_id: ${datetime_lights_on}
  - platform: homeassistant
    name: Lights Off
    id: lights_off_time
    internal: false
    entity_id: ${datetime_lights_off}


binary_sensor:
# This sensor checks if the current VWC is lower than the "VWC too low" setting 
# and will return true and eventually call an emergency irrigation if its during lights off, in order to prevent wilting overnight.
  - platform: template 
    id: p3_needs_water
    name: "P3 Needs Water"
    lambda: |-
      if (id(VWC).state <= id(p3_vwc_low_limit).state) {
        return true;
      } else {
        return false;
      }

# This is going to be set true by the P1 script once it hits field capacity.
  - platform: template
    id: p1_at_field_capacity
    name: "At Field Capacity"
    
# Here We define the steering and irrgation phases.
# Steering phases will change as the grow progresses,
# And irrigation phases change as the day progresses.
select:
  - platform: template
    name: "Steering Phase"
    id: steering_phase
    options:
     - "Vegetative - Veg"
     - "Generative - Flip"
     - "Vegetative - Bulk"
     - "Generative - Finish"
    initial_option: "Vegetative - Veg"
    optimistic: true
  - platform: template
    name: "Irrigation Phase"
    id: irrigation_phase
    options:
     - "P0"
     - "P1"
     - "P2"
     - "P3"
    initial_option: "P3"
    optimistic: True
# To-Do: add a selector for media type selection to affect VWC and pwEC calibrations


# Here we are getting the time from home assistant.
# Using time, and the Lights on and lights off and p2 window close time,
# we can run scripts and set variables at lights on and lights off.
# Currently this runs once a minute, converts the current time to HH:MM:SS in a string
# and compares that to lights on time and lights off time.
# We can add additional times, to trigger a manual P0>P1 or P1>P2 transition at set times of day
time:
  - platform: homeassistant
    id: ha_time
    on_time:
      seconds: 0
      minutes: /1
      then:
        lambda: |-
          char str[9];
          time_t currTime = id(ha_time).now().timestamp;
          strftime(str, sizeof(str), "%H:%M:%S", localtime(&currTime));
          if (str == to_string(id(lights_on_time).state)) { // Compare strings using strcmp
            ESP_LOGD("main", "This would be lights on");
          }
          if (str == to_string(id(lights_off_time).state)) { // Compare strings using strcmp
            ESP_LOGD("main", "This would be lights off");
          }
